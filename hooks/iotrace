#!/usr/bin/perl

# Program: iotrace
# Purpose: Act like strace for Linux enough to log STDIN STDOUT STDERR I/O.
# This is used for man-in-the-middle logging but will not alter any packets.

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use IPC::Open3 qw(open3);
use IO::Select;
use IO::Handle;

Getopt::Long::Configure("require_order");
Getopt::Long::Configure("bundling");
GetOptions
    "o=s"   => \(my $output_log_file),
    "v+"    => \(my $verbose = 0),
    "x+"    => \(my $heX_ify = 0),
    "t+"    => \(my $timing = 0),
    "f+"    => \(my $follow_fork), # Ignored
    "s=i"   => \(my $size_of_strings), # Ignored
    "e=s"   => \(my $events),  # Ignored
    or die "Usage> $0 -o <output_log> CMD [ARGS]\n";

my @run = @ARGV or die "$0: Missing command?\n";

if ($timing > 1 and not eval { require Time::HiRes; 1 }) {
    # If requesting get high precision, but without HiRes, then just change "-tt" to "-t"
    $timing = 1;
}

sub t {
    return "" if !$timing;
    my $now = $timing > 1 ? Time::HiRes::time() : time();
    my @t = localtime $now;
    return sprintf "%02d:%02d:%02d.%06d ", $t[2], $t[1], $t[0], 1000000*($now - int($now)) if $timing > 1;
    return sprintf "%02d:%02d:%02d ", $t[2], $t[1], $t[0];
}

# Escape strings like strace does
sub e {
    my $chars = shift;
    if ($heX_ify > 1) {
        # -xx: Super Hex Encode everything
        $chars =~ s/([\s\S])/sprintf "\\x%02x", ord($1)/eg;
    }
    else {
        $chars =~ s/\\/\\\\/g;
        $chars =~ s/\"/\\\"/g;
        $chars =~ s/\n/\\n/g;
        $chars =~ s/\r/\\r/g;
        if ($heX_ify) {
            # -x: Hex Encode only non-ascii chars
            $chars =~ s/([^\ -\~])/sprintf "\\x%02x", ord $1/eg;
        }
        else {
            # Default is octal encoding non-ascii only
            $chars =~ s/([^\ -\~])/sprintf "\\%03o", ord $1/eg;
        }
   }
   return qq{"$chars"};
}

my ($in, $out, $err, $fh_log);
$err = IO::Handle->new; # open3 can't vivify STDERR from undef for some reason
if (defined $output_log_file) {
    open $fh_log, ">", $output_log_file or die "$output_log_file: open failure: $!\n";
}
else {
    # XXX - Is it ok to spew all the trace lines out to STDERR if no -o option provided?
    open $fh_log, ">&STDERR";
}
$fh_log->autoflush(1);

my $full = $run[0];
if (eval { require File::Which; 1; } and $full =~ m{^([\w\-\.]+)$}) {
    $full = File::Which::which($1);
}
if (!$full or $full =~ m{^/} && !-x $full) {
    die "$run[0]: No such file or directory\n";
}

print $fh_log t."execve(".e($full).", [".join(', ', map { e($_) } @run).'], '.(
    $verbose ? (
        '['.join(', ', map { e("$_=$ENV{$_}") } sort keys %ENV).']'
    ) :
    \%ENV.' /* '.(scalar keys %ENV).' vars */'
).") = 0\n";

my $child_died = 0;
$SIG{CHLD} = sub { $child_died = 1; };

$run[0] = $full if $full;
my $pid = open3 $in, $out, $err, @run or die "$run[0]: fork exec failure: $!\n";

my $proxy = {
    fileno(*STDIN) => $in,
    fileno($out) => *STDOUT,
    fileno($err) => *STDERR,
};

my $io = IO::Select->new(\*STDIN, $in, $out, $err);
# Block waiting for I/O but only a little patience if the @run prog died already.
while (my @ready = $io->can_read($child_died ? 0.5 : 8000)) {
    foreach my $fh (@ready) {
        my $fn = fileno($fh);
        my $pr = $proxy->{$fn};
        if (!$pr) {
            # Open3 $in (process's STDIN) should only be written to.
            # So if it's suddenly READABLE, it means the other side explicitly closed it.
            print $fh_log t."close(0) = 0\n" if !$child_died;
            # Thus we need to do the same on our side:
            $io->remove($fh);
            $io->remove(\*STDIN);
            close STDIN;
            last;
        }
        my $bytes = sysread($fh, (my $buffer), 16384);
        # Find original fileno (STDIN=0, STDOUT=1, STDERR=2):
        my $real_fileno = $fn < 3 ? $fn : fileno($proxy->{$fn});
        # Only STDIN (fileno = 0) is "read", otherwise "write"
        my $op = $real_fileno ? "write" : "read";
        print $fh_log t."$op($real_fileno, ".e($buffer).", $bytes) = $bytes\n" if $bytes or $op eq "read";
        if ($bytes) {
            # Forward non-empty packet to the proxy file handle
            syswrite($pr, $buffer, $bytes);
        }
        else {
            # Getting ZERO bytes always means the file handle just closed.
            # Quit listening to this anymore:
            $io->remove($fh);
            # And then close the file handle for real:
            close($fh);

            # And quit listening on the corresponding handle too:
            $io->remove($pr);

            if ($real_fileno == 0 or !$child_died) {
                # Only close corresponding handle for STDIN in order to signal target program its input stream has ended, or if explicitly closed while program is still running. If target program closes an output handle (STDOUT fd 1 or STDERR fd 2) implicitely upon exit, then we want to mimic the same behavior and thus NOT explicitly close it yet:
                close($pr);

                # If it was STDIN (fd 0), then the invoker probably closed it before the target program. But just log the close acting like the target program called close itself (even if STDIN is being ignored).
                # Or if it was an output handle (STDOUT fd 1 or STDERR fd 2) and the program hasn't died, then it must have been an explicit close() so it really needs to be logged:
                print $fh_log t."close($real_fileno) = 0\n";
            }
        }
    }
    last if !$io->handles;
}

!$child_died and kill TERM => $pid and sleep 1 and kill TERM => $pid;
waitpid( $pid, 0 );
my $signal = $? & 127;
my $child_exit_status = $? >> 8;
if ($signal) {
    my $sig_name = eval { require Config; %Config::Config and [split / /, $Config::Config{sig_name}]->[$signal] } || $signal;
    print $fh_log t."--- GOT SIG$sig_name ($signal) ---\n";
}
print $fh_log t."+++ exited with $child_exit_status +++\n";
close $fh_log;
exit $child_exit_status;
